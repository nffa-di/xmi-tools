/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Thu Jun 16 2016 11:28:32 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'common/util/xmljsonconverter',
    'q'
], function (PluginConfig,
             pluginMetadata,
             PluginBase,
             converters,
             Q) {
    'use strict';

    var REF_PREFIX = '#//',
        REF_DIV = '-',
        ROOT_NAME = 'ROOT',
        CONTAINMENT_REF = 'child',
        NS_URI = 'www.webgme.org', // FIXME: This is just a dummy..
        DATA_TYPE_MAP = {
            string: 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString',
            float: 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloat',
            integer: 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt',
            boolean: 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean',
            asset: 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean',
        };

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of XMIExporter.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin XMIExporter.
     * @constructor
     */
    var XMIExporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    XMIExporter.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    XMIExporter.prototype = Object.create(PluginBase.prototype);
    XMIExporter.prototype.constructor = XMIExporter;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    XMIExporter.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            jsonToXml = new converters.JsonToXml();

        self.getXMIData(self.core, self.rootNode, self.META)
            .then(function (xmiData) {
                var languageName = self.core.getAttribute(self.rootNode, 'name'),
                    ecoreData = self.getEcoreData(self.core, self.rootNode, self.META),
                    eData = {},
                    xData = {};

                eData['ecore:EPackage'] = ecoreData;
                xData[languageName + ':' + ROOT_NAME] = xmiData;

                return Q.all([
                    self.saveFile(languageName + '.ecore', jsonToXml.convertToString(eData)),
                    self.saveFile('model.' + languageName, jsonToXml.convertToString(xData))
                ]);
            })
            .then(function () {
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                callback(err, self.result);
            });
    };

    XMIExporter.prototype.saveFile = function (fName, content) {
        var self = this,
            fs;

        if (typeof window === 'undefined' && process.env.WRITE_FILES) {
            fs = require('fs');
            return Q.ninvoke(fs, 'writeFile', fName, content);
        } else {
            return self.blobClient.putFile(fName, content)
                .then(function (metaModelHash) {
                    self.result.addArtifact(metaModelHash);
                });
        }
    };

    XMIExporter.prototype.getEcoreData = function (core, rootNode, name2MetaNode) {
        var languageName = core.getAttribute(rootNode, 'name'),
            metaNames = Object.keys(name2MetaNode),
            path2MetaNode = core.getAllMetaNodes(rootNode),
            data = {
                '@xmi:version': '2.0',
                '@xmlns:xmi': 'http://www.omg.org/XMI',
                '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
                '@xmlns:ecore': 'http://www.eclipse.org/emf/2002/Ecore',
                '@name': languageName,
                '@nsPrefix': languageName,
                '@nsURI': NS_URI,
                eClassifiers: []
            },
            i;

        data.eClassifiers.push({
            '@xsi:type': 'ecore:EClass',
            '@name': 'ROOT',
            eStructuralFeatures: [{
                '@xsi:type': 'ecore:EReference',
                '@name': CONTAINMENT_REF + REF_DIV + core.getAttribute(core.getFCO(rootNode), 'name'),
                '@eType': REF_PREFIX + core.getAttribute(core.getFCO(rootNode), 'name'),
                '@lowerBound': 0,
                '@upperBound': -1,
                '@containment': 'true',
            }]
        });

        function getAttributesData(attrs) {
            var i,
                attrNames = Object.keys(attrs),
                result = [];

            for (i = 0; i < attrNames.length; i += 1) {
                result.push({
                    '@xsi:type': 'ecore:EAttribute',
                    '@name': attrNames[i],
                    '@eType': DATA_TYPE_MAP[attrs[attrNames[i]].type]
                    //TODO: Deal with enums, ranges, regexps.
                });
            }

            return result;
        }

        function getChildrenData(children) {
            var result = [],
                i,
                childName;

            for (i = 0; i < children.items.length; i += 1) {
                childName = core.getAttribute(path2MetaNode[children.items[i]], 'name');
                result.push({
                    '@xsi:type': 'ecore:EReference',
                    '@name': CONTAINMENT_REF + REF_DIV + childName,
                    '@eType': REF_PREFIX + childName,
                    '@lowerBound': children.minItems[i] === -1 ? 0 : children.minItems[i],
                    '@upperBound': children.maxItems[i],
                    '@containment': 'true',
                });
            }

            return result;
        }

        function getPointersAndSetsData(refs) {
            var result = [],
                refNames = Object.keys(refs),
                i,
                j,
                ref,
                targetName;

            for (i = 0; i < refNames.length; i += 1) {
                ref = refs[refNames[i]];
                for (j = 0; j < ref.items.length; j += 1) {
                    targetName = core.getAttribute(path2MetaNode[ref.items[j]], 'name');
                    result.push({
                        '@xsi:type': 'ecore:EReference',
                        '@name': refNames[i] + REF_DIV + targetName,
                        '@eType': REF_PREFIX + targetName,
                        '@lowerBound': ref.minItems[j] === -1 ? 0 : ref.minItems[j],
                        '@upperBound': ref.maxItems[j],
                    });
                }
            }

            return result;
        }

        function getMetaNodeData(name, node) {
            var metaData = {
                    '@xsi:type': 'ecore:EClass',
                    '@name': name,
                    eStructuralFeatures: []
                },
                baseNode = core.getBase(node),
                metaJson;

            metaJson = core.getOwnJsonMeta(node);

            if (baseNode) {
                // TODO: check if base is meta-node
                // TODO: For libraries can we use another identifier?
                metaData['@eSuperTypes'] = REF_PREFIX + core.getAttribute(baseNode, 'name');
            } else {
                // This is the FCO -> define base pointer
                metaJson.pointers = metaJson.pointers || {};
                metaJson.pointers.base = {
                    items: [core.getPath(node)],
                    minItems: [-1],
                    maxItems: [1]
                };
            }

            if (core.isAbstract(node)) {
                metaData['@abstract'] = 'true';
            }

            if (metaJson.attributes) {
                metaData.eStructuralFeatures.push(getAttributesData(metaJson.attributes));
            }

            if (metaJson.children) {
                metaData.eStructuralFeatures.push(getChildrenData(metaJson.children));
            }

            if (metaJson.pointers) {
                metaData.eStructuralFeatures.push(getPointersAndSetsData(metaJson.pointers));
            }

            return metaData;
        }

        for (i = 0; i < metaNames.length; i += 1) {
            data.eClassifiers.push(getMetaNodeData(metaNames[i], name2MetaNode[metaNames[i]]));
        }

        return data;
    };

    XMIExporter.prototype.getXMIData = function (core, rootNode, name2MetaNode, callback) {
        var languageName = core.getAttribute(rootNode, 'name'),
            data = {
                '@xmi:version': '2.0',
                '@xmlns:xmi': 'http://www.omg.org/XMI',
                '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance'
            },
            path2Data = {};

        data['@xmlns:' + languageName] = NS_URI;
        path2Data[''] = data;

        function atNode(node, next) {
            var deferred = Q.defer(),
                parent = core.getParent(node),
                parentData = path2Data[core.getPath(parent)],
                metaNode = core.getBaseType(node),
                baseNode = core.getBase(node),
            //FIXME: Either change ecore to flatten out containment rules or match this.
                containmentRel = CONTAINMENT_REF + REF_DIV + core.getAttribute(metaNode, 'name'),
                nodeData = {
                    '@xsi:type': languageName + ':' + core.getAttribute(metaNode, 'name')
                };

            console.log('at node',core.getAttribute(node, 'name'));

            parentData[containmentRel] = parentData[containmentRel] || [];

            core.getAttributeNames(node).forEach(function (attrName) {
                nodeData['@' + attrName] = core.getAttribute(node, attrName);
            });

            if (metaNode !== node) {
                //FIXME: This id is not the correct one.
                //FIXME: Either add ids to the nodes or order the nodes and generated ids based on that.
                nodeData['@base'] = core.getPath(baseNode);
            }

            core.getPointerNames(node).forEach(function (ptrName) {
                //FIXME: This ptrName is not correct - it needs the meta type suffix.
                //FIXME: The ids are not correct
                nodeData['@' + ptrName] = core.getPointerPath(node, ptrName);
            });

            core.getSetNames(node).forEach(function (setName) {
                //FIXME: This setName is not correct - it needs the meta type suffix.
                //FIXME: The ids are not correct
                nodeData['@' + setName] = core.getMemberPaths(node, setName).join(' ');
            });

            parentData[containmentRel].push(nodeData);
            path2Data[core.getPath(node)] = nodeData;

            deferred.resolve();
            return deferred.promise.nodeify(next);
        }

        return core.traverse(rootNode, {excludeRoot: true, stopOnError: true}, atNode)
            .then(function () {
                return data;
            });
    };

    return XMIExporter;
});